"""
User management service for tenant administrators.
Provides comprehensive user CRUD operations within tenant scope.
"""

import structlog
from datetime import datetime, timedelta
from typing import List, Optional, Dict, Any, Tuple
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, func, and_, or_, text
from sqlalchemy.orm import selectinload

from app.features.administration.users.models import (
    User, UserCreate, UserUpdate, UserResponse, UserStats,
    UserDashboardStats, UserSearchFilter, UserStatus, UserRole
)
from app.features.core.security import hash_password, validate_password_complexity
from app.features.core.base_service import BaseService

logger = structlog.get_logger(__name__)


class UserManagementService(BaseService[User]):
    """
    Comprehensive user management service for tenant administrators.

    Provides:
    - Full user CRUD operations within tenant scope
    - Password management and validation
    - Search and filtering
    - Statistics and reporting
    """

    def __init__(self, db_session: AsyncSession, tenant_id: str):
        super().__init__(db_session, tenant_id)

    async def create_user(self, user_data: UserCreate, target_tenant_id: Optional[str] = None) -> UserResponse:
        """
        Create a new user with optional cross-tenant assignment for global admins.

        Args:
            user_data: User creation data
            target_tenant_id: Optional tenant ID for global admin cross-tenant creation

        Returns:
            UserResponse: Created user information
        """
        try:
            # Determine which tenant to create user in
            effective_tenant_id = target_tenant_id or self.tenant_id

            # Validate password complexity
            password_errors = validate_password_complexity(user_data.password)
            if password_errors:
                error_msg = "Password validation failed: " + "; ".join(password_errors)
                raise ValueError(error_msg)

            # Check password confirmation
            if user_data.password != user_data.confirm_password:
                raise ValueError("Passwords do not match")

            # Check if user with this email already exists in the target tenant
            if target_tenant_id:
                # For cross-tenant creation, check the specific target tenant
                existing = await self._get_user_by_email_in_tenant(user_data.email, target_tenant_id)
            else:
                # For normal operation, check current tenant
                existing = await self.get_user_by_email(user_data.email)

            if existing:
                raise ValueError(f"User with email '{user_data.email}' already exists in this tenant")

            # Create user record
            user = User(
                name=user_data.name,
                email=user_data.email,
                hashed_password=hash_password(user_data.password),
                description=user_data.description,
                status=user_data.status.value,
                role=user_data.role.value,
                enabled=user_data.enabled,
                tags=user_data.tags,
                tenant_id=effective_tenant_id  # KEY: Assign to target tenant
            )

            self.db.add(user)
            await self.db.flush()
            await self.db.refresh(user)

            logger.info("User created successfully",
                       user_id=user.id,
                       user_name=user.name,
                       user_email=user.email,
                       tenant_id=self.tenant_id,
                       operation="user_creation")

            return self._user_to_response(user)

        except Exception as e:
            await self.db.rollback()
            logger.error("User creation failed",
                        error=str(e),
                        user_email=user_data.email,
                        tenant_id=self.tenant_id,
                        operation="user_creation",
                        exc_info=True)
            raise

    async def get_user_by_id(self, user_id: str) -> Optional[UserResponse]:
        """Get user by ID within tenant scope."""
        user = await super().get_by_id(User, user_id)
        if not user:
            return None
        return self._user_to_response(user)

    async def get_user_by_email(self, email: str) -> Optional[UserResponse]:
        """Get user by email within tenant scope."""
        stmt = select(User).where(
            and_(
                User.email == email,
                User.tenant_id == self.tenant_id
            )
        )
        result = await self.db.execute(stmt)
        user = result.scalar_one_or_none()

        if not user:
            return None

        return self._user_to_response(user)

    async def update_user(self, user_id: str, user_data: UserUpdate) -> Optional[UserResponse]:
        """Update user information within tenant scope."""
        try:
            stmt = select(User).where(
                and_(
                    User.id == user_id,
                    User.tenant_id == self.tenant_id
                )
            )
            result = await self.db.execute(stmt)
            user = result.scalar_one_or_none()

            if not user:
                return None

            # Update fields if provided
            update_fields = user_data.model_dump(exclude_unset=True)

            for field, value in update_fields.items():
                if hasattr(user, field):
                    if field in ['status', 'role'] and hasattr(value, 'value'):
                        setattr(user, field, value.value)
                    else:
                        setattr(user, field, value)

            await self.db.flush()
            await self.db.refresh(user)

            logger.info("User updated successfully",
                       user_id=user_id,
                       user_name=user.name,
                       user_email=user.email,
                       tenant_id=self.tenant_id,
                       updated_fields=list(update_fields.keys()),
                       operation="user_update")

            return self._user_to_response(user)

        except Exception as e:
            await self.db.rollback()
            logger.error("User update failed",
                        error=str(e),
                        user_id=user_id,
                        tenant_id=self.tenant_id,
                        operation="user_update",
                        exc_info=True)
            raise

    async def update_user_field(self, user_id: str, field: str, value) -> Optional[UserResponse]:
        """Update a single field of a user within tenant scope."""
        try:
            stmt = select(User).where(
                and_(
                    User.id == user_id,
                    User.tenant_id == self.tenant_id
                )
            )
            result = await self.db.execute(stmt)
            user = result.scalar_one_or_none()

            if not user:
                return None

            if hasattr(user, field) and field != 'hashed_password':
                setattr(user, field, value)
                await self.db.flush()
                await self.db.refresh(user)
                return self._user_to_response(user)

            return None

        except Exception as e:
            await self.db.rollback()
            logger.error(f"Failed to update user field {field} for {user_id}: {e}")
            raise

    async def update_user_field_global(self, user_id: str, field: str, value) -> Optional[UserResponse]:
        """Update a single field of any user (global admin only)."""
        try:
            stmt = select(User).where(User.id == user_id)
            result = await self.db.execute(stmt)
            user = result.scalar_one_or_none()

            if not user:
                return None

            if hasattr(user, field) and field != 'hashed_password':
                setattr(user, field, value)
                await self.db.flush()
                await self.db.refresh(user)
                return self._user_to_response(user)

            return None

        except Exception as e:
            await self.db.rollback()
            logger.error(f"Failed to update user field {field} for {user_id}: {e}")
            raise

    async def update_user_global(self, user_id: str, user_data: UserUpdate) -> Optional[UserResponse]:
        """Update user information across all tenants (global admin only)."""
        try:
            stmt = select(User).where(User.id == user_id)
            result = await self.db.execute(stmt)
            user = result.scalar_one_or_none()

            if not user:
                return None

            # Update fields if provided
            update_fields = user_data.model_dump(exclude_unset=True)

            for field, value in update_fields.items():
                if hasattr(user, field):
                    if field in ['status', 'role'] and hasattr(value, 'value'):
                        setattr(user, field, value.value)
                    else:
                        setattr(user, field, value)

            await self.db.flush()
            await self.db.refresh(user)

            logger.info(f"Updated user: {user.name} (ID: {user_id}) globally")

            return self._user_to_response(user)

        except Exception as e:
            await self.db.rollback()
            logger.error(f"Failed to update user {user_id} globally: {e}")
            raise

    async def delete_user(self, user_id: str) -> bool:
        """
        Delete user within tenant scope.

        Args:
            user_id: User ID to delete

        Returns:
            bool: True if deleted successfully
        """
        return await super().delete_by_id(User, user_id)

    async def list_users(self, filters: Optional[UserSearchFilter] = None) -> List[UserResponse]:
        """List users within tenant with optional filtering."""
        try:
            stmt = select(User).where(User.tenant_id == self.tenant_id)

            # Apply filters if provided
            if filters:
                conditions = []

                if filters.search:
                    search_term = f"%{filters.search}%"
                    conditions.append(
                        or_(
                            User.name.ilike(search_term),
                            User.email.ilike(search_term),
                            User.description.ilike(search_term)
                        )
                    )

                if filters.status:
                    conditions.append(User.status == filters.status.value)

                if filters.role:
                    conditions.append(User.role == filters.role.value)

                if filters.enabled is not None:
                    conditions.append(User.enabled == filters.enabled)

                if filters.created_after:
                    conditions.append(User.created_at >= filters.created_after)

                if filters.created_before:
                    conditions.append(User.created_at <= filters.created_before)

                if conditions:
                    stmt = stmt.where(and_(*conditions))

            # Apply ordering and pagination
            stmt = stmt.order_by(User.created_at.desc())

            if filters:
                stmt = stmt.offset(filters.offset).limit(filters.limit)

            result = await self.db.execute(stmt)
            users = result.scalars().all()

            return [self._user_to_response(user) for user in users]

        except Exception as e:
            logger.error(f"Failed to list users: {e}")
            raise

    async def list_users_global(self, filters: Optional[UserSearchFilter] = None) -> List[UserResponse]:
        """List all users across all tenants (global admin only)."""
        try:
            # Start with all users, exclude global admins from regular listing
            stmt = select(User).where(User.role != "global_admin")

            # Apply filters if provided
            if filters:
                conditions = []

                if filters.search:
                    search_term = f"%{filters.search}%"
                    conditions.append(
                        or_(
                            User.name.ilike(search_term),
                            User.email.ilike(search_term),
                            User.description.ilike(search_term)
                        )
                    )

                if filters.status:
                    conditions.append(User.status == filters.status.value)

                if filters.role:
                    conditions.append(User.role == filters.role.value)

                if filters.enabled is not None:
                    conditions.append(User.enabled == filters.enabled)

                if filters.created_after:
                    conditions.append(User.created_at >= filters.created_after)

                if filters.created_before:
                    conditions.append(User.created_at <= filters.created_before)

                if conditions:
                    stmt = stmt.where(and_(*conditions))

            # Apply ordering and pagination
            stmt = stmt.order_by(User.created_at.desc())

            if filters:
                stmt = stmt.offset(filters.offset).limit(filters.limit)

            result = await self.db.execute(stmt)
            users = result.scalars().all()

            # For global admin view, also fetch tenant names
            user_responses = []
            for user in users:
                user_response = self._user_to_response(user)

                # Add tenant name if available
                if user.tenant_id:
                    try:
                        # Convert string tenant_id to integer for tenant table query
                        tenant_id_int = int(user.tenant_id)
                        tenant_result = await self.db.execute(
                            text("SELECT name FROM tenants WHERE id = :tenant_id"),
                            {"tenant_id": tenant_id_int}
                        )
                    except (ValueError, TypeError):
                        # Handle case where tenant_id is not a valid integer
                        tenant_result = None

                    tenant_row = tenant_result.first() if tenant_result else None
                    if tenant_row:
                        # Add tenant name to the response (dynamically)
                        user_dict = user_response.model_dump()
                        user_dict['tenant_name'] = tenant_row.name
                        user_responses.append(user_dict)
                    else:
                        user_dict = user_response.model_dump()
                        user_dict['tenant_name'] = 'Unknown'
                        user_responses.append(user_dict)
                else:
                    user_dict = user_response.model_dump()
                    user_dict['tenant_name'] = 'No Tenant'
                    user_responses.append(user_dict)

            return user_responses

        except Exception as e:
            logger.error(f"Failed to list users globally: {e}")
            raise

    async def _get_user_by_email_in_tenant(self, email: str, tenant_id: str) -> Optional[User]:
        """Get user by email in a specific tenant (for global admin operations)."""
        stmt = select(User).where(
            and_(
                User.email == email,
                User.tenant_id == tenant_id,
                User.is_active == True
            )
        )
        result = await self.db.execute(stmt)
        return result.scalar_one_or_none()

    async def get_available_tenants_for_user_forms(self) -> List[dict]:
        """Get available tenants for global admin user creation forms."""
        try:
            # Query tenant table directly within user slice for form needs
            result = await self.db.execute(
                text("SELECT id, name, status FROM tenants WHERE status = 'active' ORDER BY name")
            )

            tenants = []
            for row in result:
                tenants.append({
                    'id': str(row.id),
                    'name': row.name,
                    'status': row.status
                })

            return tenants
        except Exception as e:
            logger.error(f"Failed to get available tenants: {e}")
            return []

    async def get_dashboard_stats(self) -> UserDashboardStats:
        """Get comprehensive dashboard statistics for user management."""
        try:
            # Total user counts by status
            status_counts = await self.db.execute(
                select(
                    User.status,
                    func.count(User.id)
                ).where(User.tenant_id == self.tenant_id).group_by(User.status)
            )
            status_map = dict(status_counts.fetchall())

            # Role distribution
            role_counts = await self.db.execute(
                select(
                    User.role,
                    func.count(User.id)
                ).where(User.tenant_id == self.tenant_id).group_by(User.role)
            )
            role_map = dict(role_counts.fetchall())

            # Recent users (last 5)
            recent_users_stmt = select(User).where(
                User.tenant_id == self.tenant_id
            ).order_by(
                User.created_at.desc()
            ).limit(5)
            recent_result = await self.db.execute(recent_users_stmt)
            recent_users = recent_result.scalars().all()

            recent_user_responses = [self._user_to_response(user) for user in recent_users]

            return UserDashboardStats(
                total_users=sum(status_map.values()),
                active_users=status_map.get("active", 0),
                inactive_users=status_map.get("inactive", 0),
                suspended_users=status_map.get("suspended", 0),
                users_by_role=role_map,
                recent_users=recent_user_responses
            )

        except Exception as e:
            logger.error(f"Failed to get dashboard stats: {e}")
            raise

    async def get_available_tenants_for_user_forms(self) -> List[dict]:
        """Get available tenants for user form dropdowns - user slice owns this query."""
        # Query tenant table directly within user slice for form needs
        result = await self.db.execute(
            text("SELECT id, name, status FROM tenants WHERE status = 'active' ORDER BY name")
        )

        tenants = []
        for row in result:
            tenants.append({
                'id': str(row.id),
                'name': row.name,
                'status': row.status
            })

        return tenants

    def _user_to_response(self, user: User) -> UserResponse:
        """Convert User model to UserResponse schema."""
        return UserResponse(
            id=user.id,
            name=user.name,
            email=user.email,
            description=user.description,
            status=user.status,
            role=user.role,
            enabled=user.enabled,
            tags=user.tags or [],
            tenant_id=user.tenant_id,
            is_active=user.is_active,
            created_at=user.created_at.isoformat() if user.created_at else None,
            updated_at=user.updated_at.isoformat() if user.updated_at else None
        )
