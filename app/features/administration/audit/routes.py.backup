"""Audit log routes for administration interface."""

from fastapi import APIRouter, Depends, Request, HTTPException, Query
from fastapi.responses import HTMLResponse, JSONResponse
from sqlalchemy.ext.asyncio import AsyncSession
from typing import List, Optional
from datetime import datetime, timedelta
import structlog
from app.features.core.database import get_db
from app.features.core.templates import templates
from app.features.core.rate_limiter import rate_limit_api
from app.deps.tenant import tenant_dependency
from app.features.auth.dependencies import get_current_user
from app.features.auth.models import User
from .services import AuditService
from .models import AuditLog

router = APIRouter(tags=["audit"])
logger = structlog.get_logger()


async def get_audit_service(db: AsyncSession = Depends(get_db)) -> AuditService:
    """Dependency to get audit service."""
    return AuditService(db)


# Remove custom tenant function - use shared dependency instead


@router.get("/", response_class=HTMLResponse, name="audit_dashboard")
async def audit_dashboard(
    request: Request,
    tenant_id: str = Depends(tenant_dependency),
    current_user: User = Depends(get_current_user),
    audit_service: AuditService = Depends(get_audit_service)
):
    """Render the audit logs dashboard."""
    try:

        # Get audit statistics
        stats = await audit_service.get_audit_stats(tenant_id)

        # Get recent audit logs for display
        recent_logs = await audit_service.get_audit_logs(
            tenant_id=tenant_id,
            limit=20,
            sort_by="timestamp",
            sort_order="desc"
        )

        context = {
            "request": request,
            "title": "Audit Logs",
            "stats": stats,
            "recent_logs": recent_logs,
        }

        return templates.TemplateResponse(
            "audit_dashboard.html",
            context
        )

    except Exception as e:
        logger.exception("Failed to render audit dashboard")
        raise HTTPException(status_code=500, detail="Failed to load audit dashboard")


@router.get("/api/list", name="audit_logs_list_api")
async def get_audit_logs_list_api(
    request: Request,
    tenant_id: str = Depends(tenant_dependency),
    current_user: User = Depends(get_current_user),
    page: int = Query(1, ge=1),
    size: int = Query(25, ge=1, le=200),
    category: Optional[str] = Query(None),
    severity: Optional[str] = Query(None),
    user: Optional[str] = Query(None),
    action: Optional[str] = Query(None),
    date_from: Optional[str] = Query(None),
    date_to: Optional[str] = Query(None),
    sort: Optional[str] = Query("timestamp"),
    order: Optional[str] = Query("desc"),
    audit_service: AuditService = Depends(get_audit_service),
    _rate_limit: dict = Depends(rate_limit_api)
):
    """API endpoint for Tabulator table data."""
    try:
        offset = (page - 1) * size

        # Parse date filters
        date_from_dt = None
        date_to_dt = None

        if date_from:
            try:
                date_from_dt = datetime.fromisoformat(date_from.replace('Z', '+00:00'))
            except ValueError:
                raise HTTPException(status_code=400, detail="Invalid date_from format")

        if date_to:
            try:
                date_to_dt = datetime.fromisoformat(date_to.replace('Z', '+00:00'))
            except ValueError:
                raise HTTPException(status_code=400, detail="Invalid date_to format")

        # Get audit logs
        logs = await audit_service.get_audit_logs(
            tenant_id=tenant_id,
            limit=size,
            offset=offset,
            category_filter=category,
            severity_filter=severity,
            user_filter=user,
            action_filter=action,
            date_from=date_from_dt,
            date_to=date_to_dt,
            sort_by=sort or "timestamp",
            sort_order=order or "desc"
        )

        # Get total count for pagination
        total_logs = await audit_service.get_audit_logs(
            tenant_id=tenant_id,
            limit=1000000,  # Large number to get total count
            offset=0,
            category_filter=category,
            severity_filter=severity,
            user_filter=user,
            action_filter=action,
            date_from=date_from_dt,
            date_to=date_to_dt
        )

        # Convert to dictionaries
        logs_data = [log.to_dict() for log in logs]

        return JSONResponse(content={
            "items": logs_data,
            "total": len(total_logs),
            "page": page,
            "size": size
        })

    except HTTPException:
        raise
    except Exception as e:
        logger.exception("Failed to get audit logs list via API")
        raise HTTPException(status_code=500, detail="Failed to retrieve audit logs")


@router.get("/api/logs", name="audit_logs_api")
async def get_audit_logs_api(
    request: Request,
    tenant_id: str = Depends(tenant_dependency),
    current_user: User = Depends(get_current_user),
    page: int = Query(1, ge=1),
    limit: int = Query(50, ge=1, le=200),
    category: Optional[str] = Query(None),
    severity: Optional[str] = Query(None),
    user: Optional[str] = Query(None),
    action: Optional[str] = Query(None),
    date_from: Optional[str] = Query(None),
    date_to: Optional[str] = Query(None),
    sort_by: str = Query("timestamp"),
    sort_order: str = Query("desc"),
    audit_service: AuditService = Depends(get_audit_service),
    _rate_limit: dict = Depends(rate_limit_api)
):
    """API endpoint for paginated audit logs."""
    try:
        offset = (page - 1) * limit

        # Parse date filters
        date_from_dt = None
        date_to_dt = None

        if date_from:
            try:
                date_from_dt = datetime.fromisoformat(date_from.replace('Z', '+00:00'))
            except ValueError:
                raise HTTPException(status_code=400, detail="Invalid date_from format")

        if date_to:
            try:
                date_to_dt = datetime.fromisoformat(date_to.replace('Z', '+00:00'))
            except ValueError:
                raise HTTPException(status_code=400, detail="Invalid date_to format")

        # Get audit logs
        logs = await audit_service.get_audit_logs(
            tenant_id=tenant_id,
            limit=limit,
            offset=offset,
            category_filter=category,
            severity_filter=severity,
            user_filter=user,
            action_filter=action,
            date_from=date_from_dt,
            date_to=date_to_dt,
            sort_by=sort_by,
            sort_order=sort_order
        )

        # Convert to dictionaries
        logs_data = [log.to_dict() for log in logs]

        return JSONResponse(content={
            "data": logs_data,
            "page": page,
            "limit": limit,
            "total": len(logs_data)  # Note: This is not the total count, just current page
        })

    except HTTPException:
        raise
    except Exception as e:
        logger.exception("Failed to get audit logs via API")
        raise HTTPException(status_code=500, detail="Failed to retrieve audit logs")


@router.get("/api/stats", name="audit_stats_api")
async def get_audit_stats_api(
    request: Request,
    tenant_id: str = Depends(tenant_dependency),
    current_user: User = Depends(get_current_user),
    audit_service: AuditService = Depends(get_audit_service),
    _rate_limit: dict = Depends(rate_limit_api)
):
    """API endpoint for audit statistics."""
    try:
        stats = await audit_service.get_audit_stats(tenant_id)
        return JSONResponse(content=stats)

    except Exception as e:
        logger.exception("Failed to get audit stats via API")
        raise HTTPException(status_code=500, detail="Failed to retrieve audit statistics")


@router.get("/api/timeline", name="audit_timeline_api")
async def get_audit_timeline_api(
    request: Request,
    tenant_id: str = Depends(tenant_dependency),
    current_user: User = Depends(get_current_user),
    days: int = Query(7, ge=1, le=90),
    category: Optional[str] = Query(None),
    severity: Optional[str] = Query(None),
    user: Optional[str] = Query(None),
    action: Optional[str] = Query(None),
    date_from: Optional[str] = Query(None),
    date_to: Optional[str] = Query(None),
    audit_service: AuditService = Depends(get_audit_service),
    _rate_limit: dict = Depends(rate_limit_api)
):
    """API endpoint for audit activity timeline with filtering support."""
    try:
        logger.info(f"Timeline API called - tenant_id: {tenant_id}, user: {current_user}, days: {days}")
        logger.info(f"Filters - category: {category}, severity: {severity}, user: {user}, action: {action}")

        # Parse date filters
        date_from_dt = None
        date_to_dt = None

        if date_from:
            try:
                date_from_dt = datetime.fromisoformat(date_from)
            except ValueError:
                logger.warning(f"Invalid date_from format: {date_from}")

        if date_to:
            try:
                date_to_dt = datetime.fromisoformat(date_to)
            except ValueError:
                logger.warning(f"Invalid date_to format: {date_to}")

        # Get timeline data with filters
        timeline_data = await audit_service.get_audit_timeline(
            tenant_id,
            days,
            category_filter=category,
            severity_filter=severity,
            user_filter=user,
            action_filter=action,
            date_from=date_from_dt,
            date_to=date_to_dt
        )
        logger.info(f"Service returned data: {timeline_data}")

        # Transform data for chart widget compatibility
        # Chart widget expects: {categories: [], values: []} for simple line chart
        # or {series: [{name: "", data: []}]} for multi-series

        if not timeline_data:
            logger.info("No timeline data found, returning empty response")
            return JSONResponse(content={
                "categories": [],
                "series": []
            })

        try:
            # Get unique dates and categories
            dates = sorted(list(set(item['date'] for item in timeline_data)))
            categories = sorted(list(set(item['category'] for item in timeline_data)))
            logger.info(f"Processing dates: {dates}, categories: {categories}")

            # Create series data for each category
            series = []
            for category in categories:
                category_data = []
                for date in dates:
                    # Find count for this date/category combination
                    count = 0
                    for item in timeline_data:
                        if item['date'] == date and item['category'] == category:
                            count = item['count']
                            break
                    category_data.append(count)

                series.append({
                    "name": category,
                    "data": category_data
                })

            result = {
                "categories": dates,
                "series": series
            }
            logger.info(f"Returning timeline result: {result}")
            return JSONResponse(content=result)

        except Exception as data_processing_error:
            logger.exception(f"Error processing timeline data: {data_processing_error}")
            raise HTTPException(status_code=500, detail="Failed to process timeline data")

    except Exception as e:
        logger.exception("Failed to get audit timeline via API")
        raise HTTPException(status_code=500, detail="Failed to retrieve audit timeline")


@router.get("/{log_id}", name="audit_log_detail")
async def get_audit_log_detail(
    log_id: int,
    request: Request,
    tenant_id: str = Depends(tenant_dependency),
    current_user: User = Depends(get_current_user),
    audit_service: AuditService = Depends(get_audit_service)
):
    """Get detailed information about a specific audit log."""
    try:

        log = await audit_service.get_audit_log_by_id(tenant_id, log_id)
        if not log:
            raise HTTPException(status_code=404, detail="Audit log not found")

        return JSONResponse(content=log.to_dict())

    except HTTPException:
        raise
    except Exception as e:
        logger.exception(f"Failed to get audit log {log_id}")
        raise HTTPException(status_code=500, detail="Failed to retrieve audit log")


@router.get("/api/search", name="audit_search_api")
async def search_audit_logs_api(
    request: Request,
    tenant_id: str = Depends(tenant_dependency),
    current_user: User = Depends(get_current_user),
    q: str = Query(..., min_length=1),
    limit: int = Query(50, ge=1, le=200),
    audit_service: AuditService = Depends(get_audit_service),
    _rate_limit: dict = Depends(rate_limit_api)
):
    """Search audit logs by term."""
    try:

        logs = await audit_service.search_audit_logs(
            tenant_id=tenant_id,
            search_term=q,
            limit=limit
        )

        logs_data = [log.to_dict() for log in logs]

        return JSONResponse(content={
            "data": logs_data,
            "query": q,
            "count": len(logs_data)
        })

    except Exception as e:
        logger.exception(f"Failed to search audit logs with term: {q}")
        raise HTTPException(status_code=500, detail="Failed to search audit logs")


@router.get("/partials/filtered_list", response_class=HTMLResponse, name="audit_filtered_list_partial")
async def get_filtered_list_partial(
    request: Request,
    tenant_id: str = Depends(tenant_dependency),
    current_user: User = Depends(get_current_user),
    category: Optional[str] = Query(None),
    severity: Optional[str] = Query(None),
    user: Optional[str] = Query(None),
    action: Optional[str] = Query(None),
    date_from: Optional[str] = Query(None),
    date_to: Optional[str] = Query(None),
    audit_service: AuditService = Depends(get_audit_service)
):
    """Get filtered audit logs partial for HTMX updates."""
    try:
        # Parse date filters
        date_from_dt = None
        date_to_dt = None

        if date_from:
            try:
                date_from_dt = datetime.fromisoformat(date_from)
            except ValueError:
                logger.warning(f"Invalid date_from format: {date_from}")

        if date_to:
            try:
                date_to_dt = datetime.fromisoformat(date_to)
            except ValueError:
                logger.warning(f"Invalid date_to format: {date_to}")

        # Get filtered audit logs
        logs = await audit_service.get_audit_logs(
            tenant_id=tenant_id,
            limit=100,  # Show more for filtered view
            offset=0,
            category_filter=category,
            severity_filter=severity,
            user_filter=user,
            action_filter=action,
            date_from=date_from_dt,
            date_to=date_to_dt,
            sort_by="timestamp",
            sort_order="desc"
        )

        context = {
            "request": request,
            "logs": logs,
            "filters": {
                "category": category,
                "severity": severity,
                "user": user,
                "action": action,
                "date_from": date_from,
                "date_to": date_to
            }
        }

        return templates.TemplateResponse(
            "partials/filtered_table.html",
            context
        )

    except Exception as e:
        logger.exception("Failed to get filtered audit logs partial")
        raise HTTPException(status_code=500, detail="Failed to load filtered audit logs")


@router.get("/partials/log_details", response_class=HTMLResponse, name="audit_log_details_partial")
async def get_log_details_partial(
    request: Request,
    tenant_id: str = Depends(tenant_dependency),
    current_user: User = Depends(get_current_user),
    log_id: int = Query(...),
    audit_service: AuditService = Depends(get_audit_service)
):
    """Get audit log details partial for modal display."""
    try:

        log = await audit_service.get_audit_log_by_id(tenant_id, log_id)
        if not log:
            raise HTTPException(status_code=404, detail="Audit log not found")

        context = {
            "request": request,
            "log": log
        }

        return templates.TemplateResponse(
            "partials/log_details.html",
            context
        )

    except HTTPException:
        raise
    except Exception as e:
        logger.exception(f"Failed to get audit log details partial for {log_id}")
        raise HTTPException(status_code=500, detail="Failed to load audit log details")
