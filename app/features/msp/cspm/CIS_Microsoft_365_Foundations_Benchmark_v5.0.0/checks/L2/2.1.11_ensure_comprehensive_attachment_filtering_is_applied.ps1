# Control: 2.1.11 - Ensure comprehensive attachment filtering is applied
<# CIS_METADATA_START
{"Description":"The Common Attachment Types Filter lets a user block known and custom malicious\nfile types from being attached to emails. The policy provided by Microsoft covers 53\nextensions, and an additional custom list of extensions can be defined.\nThe list of 184 extensions provided in this recommendation is comprehensive but not\nexhaustive.","Impact":"For file types that are business necessary users will need to use other organizationally\napproved methods to transfer blocked extension types between business partners.","Audit":"Note: Utilizing the UI for auditing Anti-malware policies can be very time consuming so\nit is recommended to use a script like the one supplied below.\nTo Audit using PowerShell:\n1. Connect to Exchange Online using Connect-ExchangeOnline.\n2. Run the following script:\n# Evaluate each Malware policy. If one exist with more than 120 extensions\nthen\n# the script will output a report showing a list of missing extensions along\nwith\n# other parameters.\n$L2Extensions = @(\n\"7z\", \"a3x\", \"ace\", \"ade\", \"adp\", \"ani\", \"app\", \"appinstaller\",\n\"applescript\", \"application\", \"appref-ms\", \"appx\", \"appxbundle\", \"arj\",\n\"asd\", \"asx\", \"bas\", \"bat\", \"bgi\", \"bz2\", \"cab\", \"chm\", \"cmd\", \"com\",\n\"cpl\", \"crt\", \"cs\", \"csh\", \"daa\", \"dbf\", \"dcr\", \"deb\",\n\"desktopthemepackfile\", \"dex\", \"diagcab\", \"dif\", \"dir\", \"dll\", \"dmg\",\n\"doc\", \"docm\", \"dot\", \"dotm\", \"elf\", \"eml\", \"exe\", \"fxp\", \"gadget\", \"gz\",\n\"hlp\", \"hta\", \"htc\", \"htm\", \"html\", \"hwpx\", \"ics\", \"img\",\n\"inf\", \"ins\", \"iqy\", \"iso\", \"isp\", \"jar\", \"jnlp\", \"js\", \"jse\", \"kext\",\n\"ksh\", \"lha\", \"lib\", \"library-ms\", \"lnk\", \"lzh\", \"macho\", \"mam\", \"mda\",\n\"mdb\", \"mde\", \"mdt\", \"mdw\", \"mdz\", \"mht\", \"mhtml\", \"mof\", \"msc\", \"msi\",\n\"msix\", \"msp\", \"msrcincident\", \"mst\", \"ocx\", \"odt\", \"ops\", \"oxps\", \"pcd\",\n\"pif\", \"plg\", \"pot\", \"potm\", \"ppa\", \"ppam\", \"ppkg\", \"pps\", \"ppsm\", \"ppt\",\n\"pptm\", \"prf\", \"prg\", \"ps1\", \"ps11\", \"ps11xml\", \"ps1xml\", \"ps2\",\n\"ps2xml\", \"psc1\", \"psc2\", \"pub\", \"py\", \"pyc\", \"pyo\", \"pyw\", \"pyz\",\n\"pyzw\", \"rar\", \"reg\", \"rev\", \"rtf\", \"scf\", \"scpt\", \"scr\", \"sct\",\n\"searchConnector-ms\", \"service\", \"settingcontent-ms\", \"sh\", \"shb\", \"shs\",\n\"shtm\", \"shtml\", \"sldm\", \"slk\", \"so\", \"spl\", \"stm\", \"svg\", \"swf\", \"sys\",\n\"tar\", \"theme\", \"themepack\", \"timer\", \"uif\", \"url\", \"uue\", \"vb\", \"vbe\",\n\"vbs\", \"vhd\", \"vhdx\", \"vxd\", \"wbk\", \"website\", \"wim\", \"wiz\", \"ws\", \"wsc\",\n\"wsf\", \"wsh\", \"xla\", \"xlam\", \"xlc\", \"xll\", \"xlm\", \"xls\", \"xlsb\", \"xlsm\",\n\"xlt\", \"xltm\", \"xlw\", \"xnk\", \"xps\", \"xsl\", \"xz\", \"z\"\n)\n$MissingCount = 0\n$ExtensionPolicies = $null\n$RLine = $ExtensionReport = @()\n$FilterRules = Get-MalwareFilterRule\n$DateTime = $(((Get-Date).ToUniversalTime()).ToString(\"yyyyMMddTHHmmssZ\"))\n$OutputFilePath = \"$PWD\\CIS-Report_$($DateTime).txt\"\n$RLine += \"$(Get-Date)`n\"\nfunction Test-MalwarePolicy {\nparam (\n$PolicyId\n)\n# Find the matching rule for custom policies\n$FoundRule = $null\n$FoundRule = $FilterRules |\nWhere-Object { $_.MalwareFilterPolicy -eq $PolicyId }\nif ($PolicyId.EnableFileFilter -eq $false) {\n$script:RLine += \"WARNING: Common attachments filter is disabled.\"\n}\nif ($FoundRule.State -eq 'Disabled') {\n$script:RLine += \"WARNING: The Anti-malware rule is disabled.\"\n}\n$script:RLine += \"`nManual review needed - Domains, inclusions and\nexclusions must be valid:\"\n$script:RLine += $FoundRule |\nFormat-List Name, RecipientDomainIs, Sent*, Except*\n}\n# Match any policy that has over 120 extensions defined\n$ExtensionPolicies = Get-MalwareFilterPolicy |\nWhere-Object {$_.FileTypes.Count -gt 120 }\nif (!$ExtensionPolicies) {\nWrite-Host \"`nFAIL: A policy containing the minimum number of extensions\nwas not found.\" -ForegroundColor Red\nWrite-Host \"Only policies with over 120 extensions defined will be\nevaluated.\" -ForegroundColor Red\nExit\n}\n# Check each policy for missing extensions\nforeach ($policy in $ExtensionPolicies) {\n$MissingExtensions = $L2Extensions |\nWhere-Object {\n$extension = $_; -not $policy.FileTypes.Contains($extension)\n}\nif ($MissingExtensions.Count -eq 0) {\n$RLine += \"-\" * 60\n$RLine += \"[FOUND] $($policy.Identity)\"\n$RLine += \"-\" * 60\n$RLine += \"PASS: Policy contains all extensions\"\nTest-MalwarePolicy -PolicyId $policy\n} else {\n$MissingCount++\n$ExtensionReport += @{\nIdentity = $policy.Identity\nMissingExtensions = $MissingExtensions -join ', '\n}\n}\n}\nif ($MissingCount -gt 0) {\nforeach ($fpolicy in $ExtensionReport) {\n$RLine += \"-\" * 60\n$RLine += \"[PARTIAL] $($fpolicy.Identity)\"\n$RLine += \"-\" * 60\n$RLine += \"NOTICE - The following extensions were not found:`n\"\n$RLine += \"$($fpolicy.MissingExtensions)`n\"\nTest-MalwarePolicy -PolicyId $fpolicy.Identity\n}\n}\n# Output the report to a text file\nOut-File -FilePath $OutputFilePath -InputObject $RLine\nGet-Content $OutputFilePath\nWrite-Host \"`nLog file exported to\" $OutputFilePath\n3. Review the exported results which are stored in the present working directory.\n4. A pass for this recommendation is made when an active policy is in place that\ncovers all extensions except for those explicitly defined as an exception by the\norganization. A passing policy must also be enabled and have the\nEnableFileFilter parameter enabled.\n5. Review any manual steps listed in the output, exceptions and inclusions are\norganizational specific.\nNote: Programmatically CIS-CAT will pass when 90% or more of the extensions listed\nare present in a policy, leaving 10% or approximately 18 extensions for possible\nexceptions. Organizations should evaluate these both independently and based on\nbusiness need.\nNote: The audit procedure intentionally does not include the action taken for matched\nextensions, e.g. Reject with NDR or Quarantine the message. These are considered\norganization specific and are not scored. When FileTypeAction is not specified the\naction will default to Reject the message with a non-delivery receipt (NDR).\nThe Quarantine Policy is also considered organization specific.","Remediation":"To Remediate using PowerShell:\n1. Connect to Exchange Online using Connect-ExchangeOnline.\n2. Run the following script:\n# Create an attachment policy and associated rule. The rule is\n# intentionally disabled allowing the org to enable it when ready\n$Policy = @{\nName = \"CIS L2 Attachment Policy\"\nEnableFileFilter = $true\nZapEnabled = $true\nEnableInternalSenderAdminNotifications = $true\nInternalSenderAdminAddress = 'admin@contoso.com' # Change this.\n}\n$L2Extensions = @(\n\"7z\", \"a3x\", \"ace\", \"ade\", \"adp\", \"ani\", \"app\", \"appinstaller\",\n\"applescript\", \"application\", \"appref-ms\", \"appx\", \"appxbundle\", \"arj\",\n\"asd\", \"asx\", \"bas\", \"bat\", \"bgi\", \"bz2\", \"cab\", \"chm\", \"cmd\", \"com\",\n\"cpl\", \"crt\", \"cs\", \"csh\", \"daa\", \"dbf\", \"dcr\", \"deb\",\n\"desktopthemepackfile\", \"dex\", \"diagcab\", \"dif\", \"dir\", \"dll\", \"dmg\",\n\"doc\", \"docm\", \"dot\", \"dotm\", \"elf\", \"eml\", \"exe\", \"fxp\", \"gadget\", \"gz\",\n\"hlp\", \"hta\", \"htc\", \"htm\", \"html\", \"hwpx\", \"ics\", \"img\",\n\"inf\", \"ins\", \"iqy\", \"iso\", \"isp\", \"jar\", \"jnlp\", \"js\", \"jse\", \"kext\",\n\"ksh\", \"lha\", \"lib\", \"library-ms\", \"lnk\", \"lzh\", \"macho\", \"mam\", \"mda\",\n\"mdb\", \"mde\", \"mdt\", \"mdw\", \"mdz\", \"mht\", \"mhtml\", \"mof\", \"msc\", \"msi\",\n\"msix\", \"msp\", \"msrcincident\", \"mst\", \"ocx\", \"odt\", \"ops\", \"oxps\", \"pcd\",\n\"pif\", \"plg\", \"pot\", \"potm\", \"ppa\", \"ppam\", \"ppkg\", \"pps\", \"ppsm\", \"ppt\",\n\"pptm\", \"prf\", \"prg\", \"ps1\", \"ps11\", \"ps11xml\", \"ps1xml\", \"ps2\",\n\"ps2xml\", \"psc1\", \"psc2\", \"pub\", \"py\", \"pyc\", \"pyo\", \"pyw\", \"pyz\",\n\"pyzw\", \"rar\", \"reg\", \"rev\", \"rtf\", \"scf\", \"scpt\", \"scr\", \"sct\",\n\"searchConnector-ms\", \"service\", \"settingcontent-ms\", \"sh\", \"shb\", \"shs\",\n\"shtm\", \"shtml\", \"sldm\", \"slk\", \"so\", \"spl\", \"stm\", \"svg\", \"swf\", \"sys\",\n\"tar\", \"theme\", \"themepack\", \"timer\", \"uif\", \"url\", \"uue\", \"vb\", \"vbe\",\n\"vbs\", \"vhd\", \"vhdx\", \"vxd\", \"wbk\", \"website\", \"wim\", \"wiz\", \"ws\", \"wsc\",\n\"wsf\", \"wsh\", \"xla\", \"xlam\", \"xlc\", \"xll\", \"xlm\", \"xls\", \"xlsb\", \"xlsm\",\n\"xlt\", \"xltm\", \"xlw\", \"xnk\", \"xps\", \"xsl\", \"xz\", \"z\"\n)\n# Create the policy\nNew-MalwareFilterPolicy @Policy -FileTypes $L2Extensions\n# Create the rule for all accepted domains\n$Rule = @{\nName = $Policy.Name\nEnabled = $false\nMalwareFilterPolicy = $Policy.Name\nRecipientDomainIs = (Get-AcceptedDomain).Name\nPriority = 0\n}\nNew-MalwareFilterRule @Rule\n3. When prepared enable the rule either through the UI or PowerShell.\nNote: Due to the number of extensions the UI method is not covered. The objects can\nhowever be edited in the UI or manually added using the list from the script.\n1. Navigate to Microsoft Defender at https://security.microsoft.com/\n2. Browse to Policies & rules > Threat policies > Anti-malware.","Title":"Ensure comprehensive attachment filtering is applied","ProfileApplicability":"- E3 Level 2\n- E5 Level 2","SubSection":"2.1 Email & collaboration","DefaultValue":"The following extensions are blocked by default:\nace, ani, apk, app, appx, arj, bat, cab, cmd, com, deb, dex, dll, docm, elf, exe, hta, img,\niso, jar, jnlp, kext, lha, lib, library, lnk, lzh, macho, msc, msi, msix, msp, mst, pif, ppa,\nppam, reg, rev, scf, scr, sct, sys, uif, vb, vbe, vbs, vxd, wsc, wsf, wsh, xll, xz, z","Level":"L2","CISControls":"[{\"version\": \"\", \"id\": \"9.6\", \"title\": \"Block Unnecessary File Types\", \"description\": \"Block unnecessary file types attempting to enter the enterprise's email - - gateway.\", \"ig1\": false, \"ig2\": false, \"ig3\": false}, {\"version\": \"v8\", \"id\": \"7.9\", \"title\": \"Block Unnecessary File Types\", \"description\": \"Block all e-mail attachments entering the organization's e-mail gateway if the - - file types are unnecessary for the organization's business.\", \"ig1\": false, \"ig2\": false, \"ig3\": false}, {\"version\": \"v7\", \"id\": \"8.1\", \"title\": \"Utilize Centrally Managed Anti-malware Software\", \"description\": \"Utilize centrally managed anti-malware software to continuously monitor and - - defend each of the organization's workstations and servers.\", \"ig1\": false, \"ig2\": false, \"ig3\": false}]","References":"1. https://learn.microsoft.com/en-us/powershell/module/exchange/get-\nmalwarefilterpolicy?view=exchange-ps\n2. https://learn.microsoft.com/en-us/microsoft-365/security/office-365-security/anti-\nmalware-policies-configure?view=o365-worldwide\n3. https://learn.microsoft.com/en-us/office/compatibility/office-file-format-reference","Rationale":"Blocking known malicious file types can help prevent malware-infested files from\ninfecting a host or performing other malicious attacks such as phishing and data\nextraction.\nDefining a comprehensive list of attachments can help protect against additional\nunknown and known threats. Many legacy file formats, binary files and compressed files\nhave been used as delivery mechanisms for malicious software. Organizations can\nprotect themselves from Business E-mail Compromise (BEC) by allow-listing only the\nfile types relevant to their line of business and blocking all others.","Section":"2 Microsoft 365 Defender","RecommendationId":"2.1.11"}
CIS_METADATA_END #>
# Required Services: MgGraph, ExchangeOnline
# Note: Authentication is handled centrally - do not add Connect-* commands

$ErrorActionPreference = 'Stop'

try {
    # Initialize results array
    $resourceResults = @()
    
    # Define the list of extensions to check against
    $L2Extensions = @(
        "7z", "a3x", "ace", "ade", "adp", "ani", "app", "appinstaller", "applescript", "application", "appref-ms", "appx", "appxbundle", "arj", "asd", "asx", "bas", "bat", "bgi", "bz2", "cab", "chm", "cmd", "com", "cpl", "crt", "cs", "csh", "daa", "dbf", "dcr", "deb", "desktopthemepackfile", "dex", "diagcab", "dif", "dir", "dll", "dmg", "doc", "docm", "dot", "dotm", "elf", "eml", "exe", "fxp", "gadget", "gz", "hlp", "hta", "htc", "htm", "html", "hwpx", "ics", "img", "inf", "ins", "iqy", "iso", "isp", "jar", "jnlp", "js", "jse", "kext", "ksh", "lha", "lib", "library-ms", "lnk", "lzh", "macho", "mam", "mda", "mdb", "mde", "mdt", "mdw", "mdz", "mht", "mhtml", "mof", "msc", "msi", "msix", "msp", "msrcincident", "mst", "ocx", "odt", "ops", "oxps", "pcd", "pif", "plg", "pot", "potm", "ppa", "ppam", "ppkg", "pps", "ppsm", "ppt", "pptm", "prf", "prg", "ps1", "ps11", "ps11xml", "ps1xml", "ps2", "ps2xml", "psc1", "psc2", "pub", "py", "pyc", "pyo", "pyw", "pyz", "pyzw", "rar", "reg", "rev", "rtf", "scf", "scpt", "scr", "sct", "searchConnector-ms", "service", "settingcontent-ms", "sh", "shb", "shs", "shtm", "shtml", "sldm", "slk", "so", "spl", "stm", "svg", "swf", "sys", "tar", "theme", "themepack", "timer", "uif", "url", "uue", "vb", "vbe", "vbs", "vhd", "vhdx", "vxd", "wbk", "website", "wim", "wiz", "ws", "wsc", "wsf", "wsh", "xla", "xlam", "xlc", "xll", "xlm", "xls", "xlsb", "xlsm", "xlt", "xltm", "xlw", "xnk", "xps", "xsl", "xz", "z"
    )
    
    # Get malware filter rules and policies
    $FilterRules = Get-MalwareFilterRule
    $ExtensionPolicies = Get-MalwareFilterPolicy | Where-Object {$_.FileTypes.Count -gt 120 }
    
    # Check if any policies exist with more than 120 extensions
    if (!$ExtensionPolicies) {
        $resourceResults += @{
            Identity = "No Policy"
            IsCompliant = $false
            Message = "FAIL: A policy containing the minimum number of extensions was not found."
        }
    } else {
        # Check each policy for missing extensions
        foreach ($policy in $ExtensionPolicies) {
            $MissingExtensions = $L2Extensions | Where-Object { $extension = $_; -not $policy.FileTypes.Contains($extension) }
            if ($MissingExtensions.Count -eq 0) {
                $resourceResults += @{
                    Identity = $policy.Identity
                    IsCompliant = $true
                    Message = "PASS: Policy contains all extensions"
                }
            } else {
                $resourceResults += @{
                    Identity = $policy.Identity
                    IsCompliant = $false
                    Message = "NOTICE: Missing extensions: $($MissingExtensions -join ', ')"
                }
            }
        }
    }
    
    # Determine overall status
    $overallStatus = if (($resourceResults | Where-Object { -not $_.IsCompliant })) { 'Fail' } else { 'Pass' }
    $status_id = if ($overallStatus -eq 'Pass') { 1 } else { 3 }
    
    return @{
        status = $overallStatus
        status_id = $status_id
        Details = $resourceResults
    }
}
catch {
    Write-Error "Script execution failed: $($_.Exception.Message)"
    return @{
        status = "Error"
        status_id = 3
        Details = @()
        Error = $_.Exception.Message
    }
}
