# Control: 2.1.9 - Ensure that DKIM is enabled for all Exchange Online
<# CIS_METADATA_START
{"Description":"DKIM is one of the trio of Authentication methods (SPF, DKIM and DMARC) that help\nprevent attackers from sending messages that look like they come from your domain.\nDKIM lets an organization add a digital signature to outbound email messages in the\nmessage header. When DKIM is configured, the organization authorizes it's domain to\nassociate, or sign, its name to an email message using cryptographic authentication.\nEmail systems that get email from this domain can use a digital signature to help verify\nwhether incoming email is legitimate.\nUse of DKIM in addition to SPF and DMARC to help prevent malicious actors using\nspoofing techniques from sending messages that look like they are coming from your\ndomain.","Impact":"There should be no impact of setting up DKIM however, organizations should ensure\nappropriate setup to ensure continuous mail-flow.","Audit":"To audit using the UI:\n1. Navigate to Microsoft 365 Defender https://security.microsoft.com/\n2. Expand Email & collaboration > Policies & rules > Threat policies.\n3. Under Rules section click Email authentication settings.\n4. Select DKIM\n5. Click on each domain and confirm that Sign messages for this domain with\nDKIM signatures is Enabled and Status reads Signing DKIM signatures\nfor this domain.\n6. A status of Not signing DKIM signatures for this domain is an audit fail.\nNote: For step 5 these can also be audited the overview showing all domains. In this\ncase a passing audit procedure will be Toggle set as Enabled and Status as Valid.\nTo audit using PowerShell:\n1. Connect to Exchange Online service using Connect-ExchangeOnline.\n2. Run the following Exchange Online PowerShell command:\nGet-DkimSigningConfig | Format-Table Name,Enabled,Status\n3. For each domain verify that Enabled is True and Status is Valid.","Remediation":"To remediate using a DNS Provider:\n1. For each accepted domain in Exchange Online, two DNS entries are required.\nHost name: selector1._domainkey\nPoints to address or value: selector1-\n<domainGUID>._domainkey.<initialDomain>\nTTL: 3600\nHost name: selector2._domainkey\nPoints to address or value: selector2-\n<domainGUID>._domainkey.<initialDomain>\nTTL: 3600\nFor Office 365, the selectors will always be selector1 or selector2.\ndomainGUID is the same as the domainGUID in the customized MX record for your\ncustom domain that appears before mail.protection.outlook.com. For example, in the\nfollowing MX record for the domain contoso.com, the domainGUID is contoso-com:\ncontoso.com. 3600 IN MX 5 contoso-com.mail.protection.outlook.com\nThe initial domain is the domain that you used when you signed up for Office 365. Initial\ndomains always end with on.microsoft.com.\n1. After the DNS records are created, enable DKIM signing in Defender.\n2. Navigate to Microsoft 365 Defender https://security.microsoft.com/\n3. Expand Email & collaboration > Policies & rules > Threat policies.\n4. Under Rules section click Email authentication settings.\n5. Select DKIM\n6. Click on each domain and click Enable next to Sign messages for this\ndomain with DKIM signature.\nFinal remediation step using the Exchange Online PowerShell Module:\n1. Connect to Exchange Online service using Connect-ExchangeOnline.\n2. Run the following Exchange Online PowerShell command:\nSet-DkimSigningConfig -Identity < domainName > -Enabled $True","Title":"Ensure that DKIM is enabled for all Exchange Online","ProfileApplicability":"- E3 Level 1\n- E5 Level 1","SubSection":"2.1 Email & collaboration","DefaultValue":"","Level":"L1","CISControls":"[{\"version\": \"\", \"id\": \"9.5\", \"title\": \"Implement DMARC\", \"description\": \"v8 To lower the chance of spoofed or modified emails from valid domains, - - implement DMARC policy and verification, starting with implementing the Sender Policy Framework (SPF) and the DomainKeys Identified Mail (DKIM) standards.\", \"ig1\": false, \"ig2\": false, \"ig3\": false}, {\"version\": \"\", \"id\": \"7.8\", \"title\": \"Implement DMARC and Enable Receiver-Side\", \"description\": \"Verification v7 To lower the chance of spoofed or modified emails from valid domains, - - implement Domain-based Message Authentication, Reporting and Conformance (DMARC) policy and verification, starting by implementing the Sender Policy Framework (SPF) and the DomainKeys Identified Mail(DKIM) standards.\", \"ig1\": false, \"ig2\": false, \"ig3\": false}]","References":"1. https://learn.microsoft.com/en-us/microsoft-365/security/office-365-\nsecurity/email-authentication-dkim-configure?view=o365-worldwide","Rationale":"By enabling DKIM with Office 365, messages that are sent from Exchange Online will\nbe cryptographically signed. This will allow the receiving email system to validate that\nthe messages were generated by a server that the organization authorized and not\nbeing spoofed.","Section":"2 Microsoft 365 Defender","RecommendationId":"2.1.9"}
CIS_METADATA_END #>
# Required Services: ExchangeOnline
# Note: Authentication is handled centrally - do not add Connect-* commands

$ErrorActionPreference = 'Stop'

try {
    # Initialize results array
    $resourceResults = @()
    # Retrieve DKIM signing configuration
    $dkimConfigs = Get-DkimSigningConfig
    
    # Process each DKIM configuration
    foreach ($config in $dkimConfigs) {
        $isCompliant = $config.Enabled -eq $true
        $resourceResults += @{
            Name = $config.Name
            Enabled = $config.Enabled
            Status = $config.Status
            IsCompliant = $isCompliant
        }
    }
    
    # Determine overall status
    $overallStatus = if (($resourceResults | Where-Object { -not $_.IsCompliant })) { 'Fail' } else { 'Pass' }
    $status_id = if ($overallStatus -eq 'Pass') { 1 } else { 3 }
    
    return @{
        status = $overallStatus
        status_id = $status_id
        Details = $resourceResults
    }
}
catch {
    Write-Error "Script execution failed: $($_.Exception.Message)"
    return @{
        status = "Error"
        status_id = 3
        Details = @()
        Error = $_.Exception.Message
    }
}
